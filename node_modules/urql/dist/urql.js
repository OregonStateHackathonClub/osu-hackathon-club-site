var core = require("@urql/core");

var react = require("react");

var wonka = require("wonka");

var defaultClient = core.createClient({
  url: "/graphql"
});

var Context = react.createContext(defaultClient);

var Provider = Context.Provider;

var Consumer = Context.Consumer;

var hasWarnedAboutDefault = !1;

var useClient = function() {
  var client = react.useContext(Context);
  if ("production" !== process.env.NODE_ENV && client === defaultClient && !hasWarnedAboutDefault) {
    hasWarnedAboutDefault = !0;
    console.warn("Default Client: No client has been specified using urql's Provider.This means that urql will be falling back to defaults including making requests to `/graphql`.\nIf that's not what you want, please create a client and add a Provider.");
  }
  return client;
};

function _extends() {
  return (_extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }).apply(this, arguments);
}

var initialState = {
  fetching: !1,
  stale: !1,
  error: void 0,
  data: void 0,
  extensions: void 0
};

var useMutation = function(query) {
  var isMounted = react.useRef(!0);
  var client = useClient();
  var ref = react.useState(initialState);
  var state = ref[0];
  var setState = ref[1];
  function _ref(result) {
    if (isMounted.current) {
      setState({
        fetching: !1,
        stale: !!result.stale,
        data: result.data,
        error: result.error,
        extensions: result.extensions
      });
    }
    return result;
  }
  var executeMutation = react.useCallback((function(variables, context) {
    setState(_extends({}, initialState, {
      fetching: !0
    }));
    return wonka.toPromise(client.executeMutation(core.createRequest(query, variables), context || {})).then(_ref);
  }), [ client, query, setState ]);
  function _ref2() {
    isMounted.current = !1;
  }
  react.useEffect((function() {
    return _ref2;
  }), []);
  return [ state, executeMutation ];
};

var currentInit = !1;

var useSource = function(source, init) {
  var isMounted = react.useRef(!0);
  var ref = react.useState((function() {
    currentInit = !0;
    var initialValue = init;
    wonka.publish(wonka.onPush((function(value) {
      initialValue = value;
    }))(source)).unsubscribe();
    currentInit = !1;
    return initialValue;
  }));
  var state = ref[0];
  var setState = ref[1];
  function _ref() {
    isMounted.current = !1;
  }
  react.useEffect((function() {
    return _ref;
  }), []);
  function _ref2(value) {
    if (!currentInit && isMounted.current) {
      setState(value);
    }
  }
  react.useEffect((function() {
    return wonka.subscribe(_ref2)(source).unsubscribe;
  }), [ source ]);
  return state;
};

var useBehaviourSubject = function(value) {
  var client = useClient();
  var state = react.useMemo((function() {
    var prevValue = value;
    var subject = wonka.makeSubject();
    var prevValue$ = wonka.map((function() {
      return prevValue;
    }))(wonka.fromValue(value));
    return [ wonka.concat([ prevValue$, subject.source ]), function(value) {
      if (value !== prevValue) {
        subject.next(prevValue = value);
      }
    } ];
  }), []);
  react.useEffect((function() {
    if (!client.suspense) {
      state[1](value);
    }
  }), [ state, value ]);
  if (client.suspense) {
    state[1](value);
  }
  return state;
};

var useRequest = function(query, variables) {
  var prev = react.useRef(void 0);
  return react.useMemo((function() {
    var request = core.createRequest(query, variables);
    if (void 0 !== prev.current && prev.current.key === request.key) {
      return prev.current;
    } else {
      prev.current = request;
      return request;
    }
  }), [ query, variables ]);
};

function _ref(result, partial) {
  return _extends({}, result, partial);
}

function _ref2(ref) {
  return {
    fetching: !1,
    stale: !!ref.stale,
    data: ref.data,
    error: ref.error,
    extensions: ref.extensions
  };
}

function _ref3(query$) {
  if (!query$) {
    return wonka.fromValue({
      fetching: !1,
      stale: !1
    });
  }
  return wonka.concat([ wonka.fromValue({
    fetching: !0,
    stale: !1
  }), wonka.map(_ref2)(query$), wonka.fromValue({
    fetching: !1,
    stale: !1
  }) ]);
}

var useQuery = function(args) {
  var client = useClient();
  var request = useRequest(args.query, args.variables);
  var makeQuery$ = react.useCallback((function(opts) {
    return client.executeQuery(request, _extends({}, {
      requestPolicy: args.requestPolicy,
      pollInterval: args.pollInterval
    }, args.context, opts));
  }), [ client, request, args.requestPolicy, args.pollInterval, args.context ]);
  var ref = useBehaviourSubject(react.useMemo((function() {
    return args.pause ? null : makeQuery$();
  }), [ args.pause, makeQuery$ ]));
  var query$$ = ref[0];
  var update = ref[1];
  return [ useSource(react.useMemo((function() {
    return wonka.scan(_ref, initialState)(wonka.switchMap(_ref3)(query$$));
  }), [ query$$ ]), initialState), react.useCallback((function(opts) {
    return update(makeQuery$(opts));
  }), [ update, makeQuery$ ]) ];
};

function _ref2$1(ref) {
  return {
    fetching: !0,
    stale: !!ref.stale,
    data: ref.data,
    error: ref.error,
    extensions: ref.extensions
  };
}

function _ref3$1(subscription$) {
  if (!subscription$) {
    return wonka.fromValue({
      fetching: !1
    });
  }
  return wonka.concat([ wonka.fromValue({
    fetching: !0,
    stale: !1
  }), wonka.map(_ref2$1)(subscription$), wonka.fromValue({
    fetching: !1,
    stale: !1
  }) ]);
}

var useSubscription = function(args, handler) {
  var client = useClient();
  var handlerRef = react.useRef(handler);
  handlerRef.current = handler;
  var request = useRequest(args.query, args.variables);
  var makeSubscription$ = react.useCallback((function(opts) {
    return client.executeSubscription(request, _extends({}, args.context, opts));
  }), [ client, request, args.context ]);
  var ref = useBehaviourSubject(react.useMemo((function() {
    return args.pause ? null : makeSubscription$();
  }), [ args.pause, makeSubscription$ ]));
  var subscription$$ = ref[0];
  var update = ref[1];
  function _ref(result, partial) {
    var handler = handlerRef.current;
    return _extends({}, result, partial, {
      data: void 0 !== partial.data ? "function" == typeof handler ? handler(result.data, partial.data) : partial.data : result.data
    });
  }
  return [ useSource(react.useMemo((function() {
    return wonka.scan(_ref, initialState)(wonka.switchMap(_ref3$1)(subscription$$));
  }), [ subscription$$ ]), initialState), react.useCallback((function(opts) {
    return update(makeSubscription$(opts));
  }), [ update, makeSubscription$ ]) ];
};

Object.keys(core).forEach((function(k) {
  if ("default" !== k) {
    exports[k] = core[k];
  }
}));

exports.Consumer = Consumer;

exports.Context = Context;

exports.Mutation = function Mutation(props) {
  var ref = useMutation(props.query);
  return props.children(_extends({}, ref[0], {
    executeMutation: ref[1]
  }));
};

exports.Provider = Provider;

exports.Query = function Query(props) {
  var ref = useQuery(props);
  return props.children(_extends({}, ref[0], {
    executeQuery: ref[1]
  }));
};

exports.Subscription = function Subscription(props) {
  var ref = useSubscription(props, props.handler);
  return props.children(_extends({}, ref[0], {
    executeSubscription: ref[1]
  }));
};

exports.useClient = useClient;

exports.useMutation = useMutation;

exports.useQuery = useQuery;

exports.useSubscription = useSubscription;
//# sourceMappingURL=urql.js.map
