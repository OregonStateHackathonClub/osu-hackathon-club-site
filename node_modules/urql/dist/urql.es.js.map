{"version":3,"file":"urql.es.js","sources":["../src/context.ts","../src/hooks/constants.ts","../src/hooks/useMutation.ts","../src/hooks/useSource.ts","../src/hooks/useRequest.ts","../src/hooks/useQuery.ts","../src/hooks/useSubscription.ts","../src/components/Mutation.ts","../src/components/Query.ts","../src/components/Subscription.ts"],"sourcesContent":["import { createContext, useContext } from 'react';\nimport { Client, createClient } from '@urql/core';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n};\n","import { DocumentNode } from 'graphql';\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { pipe, toPromise } from 'wonka';\n\nimport {\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { initialState } from './constants';\n\nexport interface UseMutationState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseMutationResponse<T, V> = [\n  UseMutationState<T>,\n  (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>\n];\n\nexport const useMutation = <T = any, V = object>(\n  query: DocumentNode | string\n): UseMutationResponse<T, V> => {\n  const isMounted = useRef(true);\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<T>>(initialState);\n\n  const executeMutation = useCallback(\n    (variables?: V, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      return pipe(\n        client.executeMutation(\n          createRequest(query, variables as any),\n          context || {}\n        ),\n        toPromise\n      ).then(result => {\n        if (isMounted.current) {\n          setState({\n            fetching: false,\n            stale: !!result.stale,\n            data: result.data,\n            error: result.error,\n            extensions: result.extensions,\n          });\n        }\n        return result;\n      });\n    },\n    [client, query, setState]\n  );\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n};\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { useMemo, useEffect, useState, useRef } from 'react';\n\nimport {\n  Source,\n  fromValue,\n  makeSubject,\n  pipe,\n  map,\n  concat,\n  onPush,\n  publish,\n  subscribe,\n} from 'wonka';\n\nimport { useClient } from '../context';\n\nlet currentInit = false;\n\nexport const useSource = <T>(source: Source<T>, init: T): T => {\n  const isMounted = useRef(true);\n\n  const [state, setState] = useState(() => {\n    currentInit = true;\n    let initialValue = init;\n\n    pipe(\n      source,\n      onPush(value => {\n        initialValue = value;\n      }),\n      publish\n    ).unsubscribe();\n\n    currentInit = false;\n    return initialValue;\n  });\n\n  useEffect(() => {\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  useEffect(() => {\n    return pipe(\n      source,\n      subscribe(value => {\n        if (!currentInit && isMounted.current) {\n          setState(value);\n        }\n      })\n    ).unsubscribe as () => void;\n  }, [source]);\n\n  return state;\n};\n\nexport const useBehaviourSubject = <T>(value: T) => {\n  const client = useClient();\n\n  const state = useMemo((): [Source<T>, (value: T) => void] => {\n    let prevValue = value;\n\n    const subject = makeSubject<T>();\n    const prevValue$ = pipe(\n      fromValue(value),\n      map(() => prevValue)\n    );\n\n    // This turns the subject into a behaviour subject that returns\n    // the last known value (or the initial value) synchronously\n    const source = concat([prevValue$, subject.source]);\n\n    const next = (value: T) => {\n      // We can use the latest known value to also deduplicate next calls.\n      if (value !== prevValue) {\n        subject.next((prevValue = value));\n      }\n    };\n\n    return [source, next];\n  }, []);\n\n  // NOTE: This is a special case for client-side suspense.\n  // We can't trigger suspense inside an effect but only in the render function.\n  // So we \"deopt\" to not using an effect if the client is in suspense-mode.\n  useEffect(() => {\n    if (!client.suspense) state[1](value);\n  }, [state, value]);\n\n  if (client.suspense) state[1](value);\n\n  return state;\n};\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { GraphQLRequest, createRequest } from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport const useRequest = (\n  query: string | DocumentNode,\n  variables?: any\n): GraphQLRequest => {\n  const prev = useRef<undefined | GraphQLRequest>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\nimport { CombinedError, OperationContext, RequestPolicy } from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useSource, useBehaviourSubject } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseQueryArgs<V> {\n  query: string | DocumentNode;\n  variables?: V;\n  requestPolicy?: RequestPolicy;\n  pollInterval?: number;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseQueryResponse<T> = [\n  UseQueryState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useQuery = <T = any, V = object>(\n  args: UseQueryArgs<V>\n): UseQueryResponse<T> => {\n  const client = useClient();\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new query-source from client.executeQuery\n  const makeQuery$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeQuery(request, {\n        requestPolicy: args.requestPolicy,\n        pollInterval: args.pollInterval,\n        ...args.context,\n        ...opts,\n      });\n    },\n    [client, request, args.requestPolicy, args.pollInterval, args.context]\n  );\n\n  const [query$$, update] = useBehaviourSubject(\n    useMemo(() => (args.pause ? null : makeQuery$()), [args.pause, makeQuery$])\n  );\n\n  const state = useSource(\n    useMemo(() => {\n      return pipe(\n        query$$,\n        switchMap(query$ => {\n          if (!query$) return fromValue({ fetching: false, stale: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              query$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: false,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan(\n          (result, partial) => ({\n            ...result,\n            ...partial,\n          }),\n          initialState\n        )\n      );\n    }, [query$$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeQuery$(opts)),\n    [update, makeQuery$]\n  );\n\n  return [state, executeQuery];\n};\n","import { DocumentNode } from 'graphql';\nimport { useCallback, useRef, useMemo } from 'react';\nimport { pipe, concat, fromValue, switchMap, map, scan } from 'wonka';\nimport { CombinedError, OperationContext } from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useSource, useBehaviourSubject } from './useSource';\nimport { useRequest } from './useRequest';\nimport { initialState } from './constants';\n\nexport interface UseSubscriptionArgs<V> {\n  query: DocumentNode | string;\n  variables?: V;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<T> {\n  fetching: boolean;\n  stale: boolean;\n  data?: T;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n}\n\nexport type UseSubscriptionResponse<T> = [\n  UseSubscriptionState<T>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport const useSubscription = <T = any, R = T, V = object>(\n  args: UseSubscriptionArgs<V>,\n  handler?: SubscriptionHandler<T, R>\n): UseSubscriptionResponse<R> => {\n  const client = useClient();\n\n  // Update handler on constant ref, since handler changes shouldn't\n  // trigger a new subscription run\n  const handlerRef = useRef(handler);\n  handlerRef.current = handler;\n\n  // This creates a request which will keep a stable reference\n  // if request.key doesn't change\n  const request = useRequest(args.query, args.variables);\n\n  // Create a new subscription-source from client.executeSubscription\n  const makeSubscription$ = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      return client.executeSubscription(request, { ...args.context, ...opts });\n    },\n    [client, request, args.context]\n  );\n\n  const [subscription$$, update] = useBehaviourSubject(\n    useMemo(() => (args.pause ? null : makeSubscription$()), [\n      args.pause,\n      makeSubscription$,\n    ])\n  );\n\n  const state = useSource(\n    useMemo(() => {\n      return pipe(\n        subscription$$,\n        switchMap(subscription$ => {\n          if (!subscription$) return fromValue({ fetching: false });\n\n          return concat([\n            // Initially set fetching to true\n            fromValue({ fetching: true, stale: false }),\n            pipe(\n              subscription$,\n              map(({ stale, data, error, extensions }) => ({\n                fetching: true,\n                stale: !!stale,\n                data,\n                error,\n                extensions,\n              }))\n            ),\n            // When the source proactively closes, fetching is set to false\n            fromValue({ fetching: false, stale: false }),\n          ]);\n        }),\n        // The individual partial results are merged into each previous result\n        scan((result, partial: any) => {\n          const { current: handler } = handlerRef;\n          // If a handler has been passed, it's used to merge new data in\n          const data =\n            partial.data !== undefined\n              ? typeof handler === 'function'\n                ? handler(result.data, partial.data)\n                : partial.data\n              : result.data;\n          return { ...result, ...partial, data };\n        }, initialState)\n      );\n    }, [subscription$$]),\n    initialState\n  );\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => update(makeSubscription$(opts)),\n    [update, makeSubscription$]\n  );\n\n  return [state, executeSubscription];\n};\n","import { ReactElement } from 'react';\nimport { DocumentNode } from 'graphql';\nimport { OperationResult, OperationContext } from '@urql/core';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<T, V> {\n  query: DocumentNode | string;\n  children: (arg: MutationState<T, V>) => ReactElement<any>;\n}\n\nexport interface MutationState<T, V> extends UseMutationState<T> {\n  executeMutation: (\n    variables?: V,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<T>>;\n}\n\nexport function Mutation<T = any, V = any>(\n  props: MutationProps<T, V>\n): ReactElement<any> {\n  const [state, executeMutation] = useMutation<T, V>(props.query);\n  return props.children({ ...state, executeMutation });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<T, V> extends UseQueryArgs<V> {\n  children: (arg: QueryState<T>) => ReactElement<any>;\n}\n\nexport interface QueryState<T> extends UseQueryState<T> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<T = any, V = any>(\n  props: QueryProps<T, V>\n): ReactElement<any> {\n  const [state, executeQuery] = useQuery<T, V>(props);\n  return props.children({ ...state, executeQuery });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<T, R, V> extends UseSubscriptionArgs<V> {\n  handler?: SubscriptionHandler<T, R>;\n  children: (arg: SubscriptionState<R>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<T> extends UseSubscriptionState<T> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<T = any, R = T, V = any>(\n  props: SubscriptionProps<T, R, V>\n): ReactElement<any> {\n  const [state, executeSubscription] = useSubscription<T, R, V>(\n    props,\n    props.handler\n  );\n  return props.children({ ...state, executeSubscription });\n}\n"],"names":["const","defaultClient","createClient","url","Context","createContext","Provider","Consumer","let","hasWarnedAboutDefault","useClient","client","useContext","process","env","NODE_ENV","console","warn","initialState","fetching","stale","error","undefined","data","extensions","useMutation","query","isMounted","useRef","useState","result","current","setState","executeMutation","useCallback","variables","context","_extends","toPromise","createRequest","then","useEffect","state","currentInit","useSource","source","init","initialValue","publish","onPush","value","unsubscribe","subscribe","useBehaviourSubject","useMemo","prevValue","subject","makeSubject","prevValue$","map","fromValue","concat","next","suspense","useRequest","prev","request","key","partial","query$","useQuery","args","makeQuery$","opts","executeQuery","requestPolicy","pollInterval","pause","scan","switchMap","query$$","update","subscription$","useSubscription","handler","handlerRef","makeSubscription$","executeSubscription","subscription$$","Mutation","props","children","Query","Subscription"],"mappings":"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"}