"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

exports.__esModule = true;
exports.recipesHandler = recipesHandler;

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _gatsbyTelemetry = require("gatsby-telemetry");

var _execa = _interopRequireDefault(require("execa"));

var path = _interopRequireWildcard(require("path"));

var fs = _interopRequireWildcard(require("fs"));

var _detectPort = _interopRequireDefault(require("detect-port"));

function recipesHandler(_x) {
  return _recipesHandler.apply(this, arguments);
}

function _recipesHandler() {
  _recipesHandler = (0, _asyncToGenerator2.default)(function* (recipe) {
    var _subprocess$stderr, _subprocess$stdout2;

    // We don't really care what port is used for GraphQL as it's
    // generally only for code to code communication or debugging.
    const graphqlPort = yield (0, _detectPort.default)(4000);
    (0, _gatsbyTelemetry.trackCli)(`RECIPE_RUN`, {
      name: recipe
    }); // Start GraphQL serve

    const scriptPath = require.resolve(`gatsby-recipes/dist/graphql.js`);

    const subprocess = (0, _execa.default)(`node`, [scriptPath, graphqlPort], {
      all: true,
      env: {
        // Chalk doesn't want to output color in a child process
        // as it (correctly) thinks it's not in a normal terminal environemnt.
        // Since we're just returning data, we'll override that.
        FORCE_COLOR: `true`
      }
    }); // eslint-disable-next-line no-unused-expressions

    (_subprocess$stderr = subprocess.stderr) === null || _subprocess$stderr === void 0 ? void 0 : _subprocess$stderr.on(`data`, data => {
      console.log(data.toString());
    });
    process.on(`exit`, () => {
      subprocess.kill(`SIGTERM`, {
        forceKillAfterTimeout: 2000
      });
    }); // Log server output to a file.

    if (process.env.DEBUG) {
      var _subprocess$stdout;

      const logFile = path.resolve(`./recipe-server.log`);
      fs.writeFileSync(logFile, `\n-----\n${new Date().toJSON()}\n`);
      const writeStream = fs.createWriteStream(logFile, {
        flags: `a`
      }); // eslint-disable-next-line no-unused-expressions

      (_subprocess$stdout = subprocess.stdout) === null || _subprocess$stdout === void 0 ? void 0 : _subprocess$stdout.pipe(writeStream);
    }

    let started = false; // eslint-disable-next-line no-unused-expressions

    (_subprocess$stdout2 = subprocess.stdout) === null || _subprocess$stdout2 === void 0 ? void 0 : _subprocess$stdout2.on(`data`, () => {
      if (!started) {
        const runRecipe = require(`gatsby-recipes/dist/index.js`);

        runRecipe({
          recipe,
          graphqlPort,
          projectRoot: process.cwd()
        });
        started = true;
      }
    });
    return subprocess.then(() => {});
  });
  return _recipesHandler.apply(this, arguments);
}