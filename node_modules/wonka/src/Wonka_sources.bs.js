

import * as Block from "bs-platform/lib/es6/block.js";
import * as Caml_option from "bs-platform/lib/es6/caml_option.js";
import * as Wonka_helpers from "./helpers/Wonka_helpers.bs.js";

function fromArray(arr) {
  return (function (sink) {
      var size = arr.length;
      var index = {
        contents: 0
      };
      return Wonka_helpers.makeTrampoline(sink, (function () {
                    if (index.contents < size) {
                      var x = arr[index.contents];
                      index.contents = index.contents + 1 | 0;
                      return Caml_option.some(x);
                    }
                    
                  }));
    });
}

function fromList(ls) {
  return (function (sink) {
      var value = {
        contents: ls
      };
      return Wonka_helpers.makeTrampoline(sink, (function () {
                    var match = value.contents;
                    if (match) {
                      value.contents = match[1];
                      return Caml_option.some(match[0]);
                    }
                    
                  }));
    });
}

function fromValue(x) {
  return (function (sink) {
      var ended = {
        contents: false
      };
      return sink(/* Start */Block.__(0, [(function (signal) {
                        if (signal) {
                          ended.contents = true;
                          return /* () */0;
                        } else if (ended.contents) {
                          return /* () */0;
                        } else {
                          ended.contents = true;
                          sink(/* Push */Block.__(1, [x]));
                          return sink(/* End */0);
                        }
                      })]));
    });
}

function make(f) {
  return (function (sink) {
      var state = {
        teardown: (function () {
            return /* () */0;
          }),
        ended: false
      };
      state.teardown = f({
            next: (function (value) {
                if (state.ended) {
                  return 0;
                } else {
                  return sink(/* Push */Block.__(1, [value]));
                }
              }),
            complete: (function (param) {
                if (state.ended) {
                  return 0;
                } else {
                  state.ended = true;
                  return sink(/* End */0);
                }
              })
          });
      return sink(/* Start */Block.__(0, [(function (signal) {
                        if (signal && !state.ended) {
                          state.ended = true;
                          return state.teardown();
                        } else {
                          return /* () */0;
                        }
                      })]));
    });
}

function makeSubject(param) {
  var state = {
    sinks: new Array(),
    ended: false
  };
  var source = function (sink) {
    state.sinks = state.sinks.concat(sink);
    return sink(/* Start */Block.__(0, [(function (signal) {
                      if (signal) {
                        state.sinks = state.sinks.filter((function (x) {
                                return x !== sink;
                              }));
                        return /* () */0;
                      } else {
                        return /* () */0;
                      }
                    })]));
  };
  var next = function (value) {
    if (state.ended) {
      return 0;
    } else {
      state.sinks.forEach((function (sink) {
              return sink(/* Push */Block.__(1, [value]));
            }));
      return /* () */0;
    }
  };
  var complete = function (param) {
    if (state.ended) {
      return 0;
    } else {
      state.ended = true;
      state.sinks.forEach((function (sink) {
              return sink(/* End */0);
            }));
      return /* () */0;
    }
  };
  return {
          source: source,
          next: next,
          complete: complete
        };
}

function empty(sink) {
  var ended = {
    contents: false
  };
  return sink(/* Start */Block.__(0, [(function (signal) {
                    if (signal) {
                      ended.contents = true;
                      return /* () */0;
                    } else if (ended.contents) {
                      return /* () */0;
                    } else {
                      return sink(/* End */0);
                    }
                  })]));
}

function never(sink) {
  return sink(/* Start */Block.__(0, [Wonka_helpers.talkbackPlaceholder]));
}

export {
  fromArray ,
  fromList ,
  fromValue ,
  make ,
  makeSubject ,
  empty ,
  never ,
  
}
/* No side effect */
